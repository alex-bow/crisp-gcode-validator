package crisp;

import java.util.Map;
import static java.util.Map.entry;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

// This validator is intended for the parameters that are visible from the autogenerated
// PrusaSlicer comments, taking the form param = value. While it has no utility
// on random, uncommented pieces of GCode, it speeds up the library workflow where
// we require PrusaSlicer profiles that we provide.

class ConfigValidator extends ValidationModule {

    static Pattern timeStamp = Pattern.compile("(\\d+)h (\\d+)m (\\d+)s");

    void validate(LazyParser parser, Validator validator) {
        Class<? extends ConsumerModule> cl = new PrusaCommentConsumer(parser).getClass();
        PrusaCommentConsumer commentConsumer = (PrusaCommentConsumer) parser.getConsumer(cl);
        if (commentConsumer == null) {
            System.err.println("No Prusa comment consumer present on parser.");
            return;
        }

        for(Map.Entry<String, Token> entry : commentConsumer.data.entrySet()) {
            String key = entry.getKey();
            Token value = entry.getValue();

            Matcher m;
            int hours;

            // System.out.println("Attempting to parse " + key + " = " + value.strValue);
            if (key.equals("fill_density")) {
                int i;
                try {
                    i = Integer.parseInt(value.strValue.replace("%",""));
                } catch (NumberFormatException e) {
                    System.out.println(e);
                    i = 0;
                }
                if (i > 60) {
                    validator.send_status(StatusType.SOFT_FAIL_HIGH_INFILL);
                }
            } else if (key.equals("filament_type")) {
                if (!value.strValue.equals("PLA")) {
                    validator.send_status(StatusType.HARD_FAIL_FILAMENT_TYPE);
                }
            } else if (key.equals("printer_model")) {
                if (!value.strValue.equals("MK3S")) {
                    validator.send_status(StatusType.HARD_FAIL_PRINTER_TYPE);
                }
            } else if (key.equals("printer_settings_id")) {
                if (!value.strValue.equals("Prusa i3 MK3S (Marriott Library)")) {
                    validator.send_status(StatusType.HARD_FAIL_NO_PROFILE);
                }
            } else if (key.equals("estimated printing time (normal mode)")) {
                m = timeStamp.matcher(value.strValue);
                if (m.find()) {
                    hours = Integer.parseInt(m.group(1));
                    if (hours > 6) {
                        validator.send_status(StatusType.SOFT_FAIL_HUGE_PRINT);
                    }
                }
            }

        }

        // for (Map.Entry<String, List<String>> entry : forbidden.entrySet()) {
        //     Token value = commentConsumer.data.get(entry.getKey());
        //
        //     System.out.println(entry.getKey());
        //     System.out.println(value);
        //     if (value != null && (entry.getValue().contains(value.strValue) ||
        //             entry.getValue().contains(value.value))) {
        //         System.err.println("Found error in GCODE on token " + entry.getKey() +
        //             "; " + value.value + " or " + value.strValue + " is a forbidden value!");
        //     }
        // }

    }
}
